<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>es6中的_proto_</title>
</head>
<body>
    <script>
        var that;
        function Star(uname,age){
            this.uname=uname;
            this.age=age;
        }
        Star.prototype.sing=function(){
            console.log('我会唱歌');
            that=this;
        }
        var ldh=new Star('刘德华',18);
        ////////////////////////////
        //构造函数中的this指向的是实例对象
        //原型对象函数里面的this指向的是实例对象
        console.log(that==this);

        var zxy=new Star('zxy',18);
        console.log(zxy);
        //每一个实例对象都有一个__proto__指向构造函数的原型对象
        ldh.sing();
        console.log(ldh.prototype==Star.prototype);
        console.log(ldh.__proto__==Star.prototype);//每一个实例的内存地址不一样
        console.log(ldh.__proto__);
        console.log(Star.prototype);
        console.log(Star.prototype.constructor);
        //实例的__proto__==构造函数的prototype
        //方法的查找规则:首先先看ldh 对象身上是否有sing方法,如果有就执行这个对象上的sing
        //如果么有sing 这个方法,因为有_prpto__的存在,就去构造函数原型对象prototype身上去查找sing这个方法


        // 注意∶数组和字符串内置对象不能给原型对象覆盖操作Array.prototype ={}，只能是Array.prototype.xx = function(){}的方式.
    </script>
</body>
</html>